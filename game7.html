<!DOCTYPE html>
<html lang="th">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tetris | Galaxy Games</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Kanit:wght@300;400;500;700&display=swap" rel="stylesheet">
    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css">

    <style>
        :root {
            --bg-color: #0f0f1a;
            --primary-color: #1a1a2e;
            --secondary-color: #2a2a4a;
            --accent-color: #00f5d4;
            --glow-color: rgba(0, 245, 212, 0.5);
            --font-color: #e0e0e0;
        }

        * { box-sizing: border-box; }

        body {
            font-family: 'Kanit', sans-serif;
            background-color: var(--bg-color);
            color: var(--font-color);
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh; /* Use height instead of min-height */
            margin: 0;
            overflow: hidden; /* Prevent body from scrolling */
        }

        .game-container {
            display: flex;
            gap: 20px;
            padding: 20px;
            background-color: var(--primary-color);
            border-radius: 15px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.4);
            position: relative;
            transition: all 0.2s ease; /* Add transition for smooth resizing */
        }

        #tetris-canvas {
            border: 3px solid var(--accent-color);
            border-radius: 5px;
            box-shadow: 0 0 25px var(--glow-color);
        }

        .side-panel {
            width: 180px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            text-align: left;
        }

        .info-box {
            background-color: var(--bg-color);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid var(--secondary-color);
            transition: all 0.2s ease;
        }

        .info-box h1, .info-box h2 {
            margin: 0 0 10px 0;
            font-size: 1.2rem;
            color: var(--accent-color);
            border-bottom: 1px solid var(--secondary-color);
            padding-bottom: 5px;
            transition: font-size 0.2s ease;
        }
        .side-panel > h1 {
            color: white;
            border: none;
            padding: 0;
            font-size: 1.8rem;
            margin: 0;
            line-height: 1.2;
        }

        .info-box p {
            font-size: 1.5rem;
            margin: 0;
            font-weight: bold;
            transition: font-size 0.2s ease;
        }
        
        #next-piece-canvas {
            background-color: var(--bg-color);
            border-radius: 10px;
            border: 1px solid var(--secondary-color);
        }
        
        .controls, .back-link {
            text-align: center;
            margin-top: auto;
            font-size: 0.9rem;
            color: var(--font-color-muted);
        }
        .back-link a { color: var(--font-color-muted); text-decoration: none; }
        .back-link a:hover { color: var(--accent-color); }

        .overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(15, 15, 26, 0.9);
            backdrop-filter: blur(5px);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            z-index: 10;
            border-radius: 15px;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.5s ease;
        }
        .overlay.active { opacity: 1; visibility: visible; }
        .overlay h2 { font-size: 3rem; margin-bottom: 10px; }
        .overlay p { font-size: 1.5rem; margin-bottom: 30px; }
        .btn {
            padding: 12px 30px; font-size: 1.1rem; font-weight: 700;
            border-radius: 25px; border: none; cursor: pointer;
            transition: all 0.3s ease; background-color: var(--accent-color);
            color: black;
        }
        .btn:hover { transform: scale(1.05); }
        
        /* --- Responsive code for shorter screens --- */
        @media (max-height: 700px) {
            .game-container {
                padding: 10px;
                gap: 15px;
            }
            .side-panel {
                gap: 8px;
            }
            .side-panel > h1 {
                font-size: 1.5rem;
            }
            .info-box {
                padding: 8px;
            }
            .info-box h2 {
                font-size: 1rem;
                margin-bottom: 5px;
            }
            .info-box p {
                font-size: 1.2rem;
            }
        }

    </style>
</head>
<body>

    <div class="game-container">
        <canvas id="tetris-canvas" width="240" height="480"></canvas>

        <div class="side-panel">
            <h1>Galaxy Tetris</h1>
            <div class="info-box">
                <h2>คะแนน</h2>
                <p id="score">0</p>
            </div>
            <div class="info-box">
                <h2>แถว</h2>
                <p id="lines">0</p>
            </div>
            <div class="info-box">
                <h2>เลเวล</h2>
                <p id="level">1</p>
            </div>
            <div class="info-box">
                <h2>ตัวถัดไป</h2>
                <canvas id="next-piece-canvas" width="120" height="80"></canvas>
            </div>
            <div class="controls">
                <p>P = หยุด/เล่นต่อ</p>
            </div>
            <div class="back-link">
                <a href="index.html"><i class="fa-solid fa-arrow-left"></i> กลับหน้าหลัก</a>
            </div>
        </div>

        <div class="overlay" id="game-over-screen">
            <h2>Game Over</h2>
            <p>คะแนนสุดท้าย: <span id="final-score">0</span></p>
            <button class="btn" id="play-again-button">เล่นอีกครั้ง</button>
        </div>
    </div>
    
    <script>
    // Self-invoking function to encapsulate game code
    (function() {
        const canvas = document.getElementById('tetris-canvas');
        const ctx = canvas.getContext('2d');
        const nextCanvas = document.getElementById('next-piece-canvas');
        const nextCtx = nextCanvas.getContext('2d');

        const scoreEl = document.getElementById('score');
        const linesEl = document.getElementById('lines');
        const levelEl = document.getElementById('level');
        const gameOverScreen = document.getElementById('game-over-screen');
        const finalScoreEl = document.getElementById('final-score');
        const playAgainButton = document.getElementById('play-again-button');
        
        const COLS = 10;
        const ROWS = 20;
        const BLOCK_SIZE = 24;
        const COLORS = {
            'I': '#00f5d4', 'J': '#0077be', 'L': '#ff7f11', 'O': '#ffc40c',
            'S': '#8ac926', 'T': '#8338ec', 'Z': '#ff0054'
        };
        const SHAPES = {
            'I': [[1,1,1,1]], 'J': [[1,0,0], [1,1,1]], 'L': [[0,0,1], [1,1,1]],
            'O': [[1,1], [1,1]], 'S': [[0,1,1], [1,1,0]], 'T': [[0,1,0], [1,1,1]],
            'Z': [[1,1,0], [0,1,1]]
        };
        const POINTS = { 1: 100, 2: 300, 3: 500, 4: 800 };

        let board;
        let currentPiece, nextPiece;
        let score, lines, level;
        let dropCounter, dropInterval;
        let isGameOver, isPaused;
        let animationFrameId;

        class Piece {
            constructor(shape, ctx) {
                this.shape = shape;
                this.color = COLORS[shape];
                this.matrix = SHAPES[shape];
                this.ctx = ctx;
                this.x = Math.floor(COLS / 2) - Math.floor(this.matrix[0].length / 2);
                this.y = 0;
            }

            draw() {
                this.ctx.fillStyle = this.color;
                this.matrix.forEach((row, y) => {
                    row.forEach((value, x) => {
                        if (value > 0) {
                            this.ctx.fillRect((this.x + x) * BLOCK_SIZE, (this.y + y) * BLOCK_SIZE, BLOCK_SIZE - 1, BLOCK_SIZE - 1);
                        }
                    });
                });
            }

            drawGhost() {
                const ghostY = this.getDropPosition();
                this.ctx.fillStyle = this.color;
                this.ctx.globalAlpha = 0.2;
                this.matrix.forEach((row, y) => {
                    row.forEach((value, x) => {
                        if (value > 0) {
                            this.ctx.fillRect((this.x + x) * BLOCK_SIZE, (ghostY + y) * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
                        }
                    });
                });
                this.ctx.globalAlpha = 1.0;
            }

            getDropPosition() {
                let yPos = this.y;
                while (!collision(this, board, 0, 1)) {
                    this.y++;
                }
                const dropPos = this.y - 1;
                this.y = yPos;
                return dropPos;
            }
        }
        
        function rotate(matrix) {
            const result = [];
            for (let y = 0; y < matrix[0].length; y++) {
                result[y] = [];
                for (let x = 0; x < matrix.length; x++) {
                    result[y][x] = matrix[matrix.length - 1 - x][y];
                }
            }
            return result;
        }

        function collision(piece, board, offsetX = 0, offsetY = 0) {
            for (let y = 0; y < piece.matrix.length; y++) {
                for (let x = 0; x < piece.matrix[y].length; x++) {
                    if (piece.matrix[y][x] !== 0 &&
                       (board[y + piece.y + offsetY] &&
                        board[y + piece.y + offsetY][x + piece.x + offsetX]) !== 0) {
                        return true;
                    }
                }
            }
            return false;
        }
        
        function merge(piece, board) {
            piece.matrix.forEach((row, y) => {
                row.forEach((value, x) => {
                    if (value !== 0) {
                        board[y + piece.y][x + piece.x] = piece.color;
                    }
                });
            });
        }
        
        function clearLines() {
            let clearedLines = 0;
            outer: for (let y = board.length - 1; y > 0; y--) {
                for (let x = 0; x < board[y].length; x++) {
                    if (board[y][x] === 0) {
                        continue outer;
                    }
                }
                const row = board.splice(y, 1)[0].fill(0);
                board.unshift(row);
                y++;
                clearedLines++;
            }
            if (clearedLines > 0) {
                score += POINTS[clearedLines] * level;
                lines += clearedLines;
                level = Math.floor(lines / 10) + 1;
                dropInterval = 1000 / (level * 0.8 + 1); // Make speed increase more noticeable
            }
        }

        function resetPiece() {
            currentPiece = nextPiece;
            currentPiece.ctx = ctx;
            currentPiece.x = Math.floor(COLS / 2) - Math.floor(currentPiece.matrix[0].length / 2);
            currentPiece.y = 0;

            const shapes = 'TJLOSZI';
            nextPiece = new Piece(shapes[Math.floor(Math.random() * shapes.length)], nextCtx);
            
            if (collision(currentPiece, board)) {
                isGameOver = true;
                gameOverScreen.classList.add('active');
                finalScoreEl.textContent = score;
            }
        }

        function draw() {
            ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--bg-color').trim();
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            board.forEach((row, y) => {
                row.forEach((value, x) => {
                    if (value !== 0) {
                        ctx.fillStyle = value;
                        ctx.fillRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE - 1, BLOCK_SIZE - 1);
                    }
                });
            });

            currentPiece.drawGhost();
            currentPiece.draw();
            
            nextCtx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--bg-color').trim();
            nextCtx.fillRect(0, 0, nextCanvas.width, nextCanvas.height);
            const offsetX = (nextCanvas.width / BLOCK_SIZE - nextPiece.matrix[0].length) / 2;
            const offsetY = (nextCanvas.height / BLOCK_SIZE - nextPiece.matrix.length) / 2;
            nextPiece.x = offsetX;
            nextPiece.y = offsetY;
            nextPiece.draw();
            
            scoreEl.textContent = score;
            linesEl.textContent = lines;
            levelEl.textContent = level;
        }

        let lastTime = 0;
        function gameLoop(time = 0) {
            if (isGameOver || isPaused) {
                if(isGameOver) cancelAnimationFrame(animationFrameId);
                return;
            }

            const deltaTime = time - lastTime;
            lastTime = time;
            dropCounter += deltaTime;

            if (dropCounter > dropInterval) {
                movePiece(0, 1);
            }

            draw();
            animationFrameId = requestAnimationFrame(gameLoop);
        }

        function movePiece(x, y) {
            if(isGameOver) return;
            currentPiece.x += x;
            if (collision(currentPiece, board)) {
                currentPiece.x -= x;
            }
            
            if (y) {
                currentPiece.y += y;
                if (collision(currentPiece, board)) {
                    currentPiece.y--;
                    merge(currentPiece, board);
                    clearLines();
                    resetPiece();
                }
                dropCounter = 0;
            }
        }
        
        function rotatePiece() {
            if(isGameOver) return;
            const originalX = currentPiece.x;
            let offset = 1;
            const rotated = rotate(currentPiece.matrix);
            currentPiece.matrix = rotated;
            while(collision(currentPiece, board)) {
                currentPiece.x += offset;
                offset = -(offset + (offset > 0 ? 1 : -1));
                if(offset > currentPiece.matrix[0].length) {
                    currentPiece.matrix = rotate(rotate(rotate(currentPiece.matrix)));
                    currentPiece.x = originalX;
                    return;
                }
            }
        }

        function hardDrop() {
            if(isGameOver) return;
            while(!collision(currentPiece, board, 0, 1)) {
                currentPiece.y++;
            }
            merge(currentPiece, board);
            clearLines();
            resetPiece();
            dropCounter = 0;
        }

        document.addEventListener('keydown', event => {
            if (isPaused && event.key !== 'p' && event.key !== 'P') return;
            switch(event.key) {
                case 'ArrowLeft': movePiece(-1, 0); break;
                case 'ArrowRight': movePiece(1, 0); break;
                case 'ArrowDown': movePiece(0, 1); break;
                case 'ArrowUp': rotatePiece(); break;
                case ' ': hardDrop(); event.preventDefault(); break;
                case 'p': case 'P': togglePause(); break;
            }
        });

        function togglePause() {
            isPaused = !isPaused;
            if (!isPaused && !isGameOver) {
                gameLoop();
            }
        }
        
        function resetGame() {
            if(animationFrameId) cancelAnimationFrame(animationFrameId);
            board = Array.from({ length: ROWS }, () => Array(COLS).fill(0));
            score = 0;
            lines = 0;
            level = 1;
            dropInterval = 1000;
            isGameOver = false;
            isPaused = false;
            dropCounter = 0;

            const shapes = 'TJLOSZI';
            currentPiece = new Piece(shapes[Math.floor(Math.random() * shapes.length)], ctx);
            nextPiece = new Piece(shapes[Math.floor(Math.random() * shapes.length)], nextCtx);
            
            gameOverScreen.classList.remove('active');

            gameLoop();
        }

        playAgainButton.addEventListener('click', resetGame);
        
        resetGame();
    })();
    </script>
</body>
</html>